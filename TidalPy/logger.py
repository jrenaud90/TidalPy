import os
import sys
import logging
from datetime import datetime
from pathlib import Path

import TidalPy
from TidalPy.paths import get_log_dir, timestamped_str

FILE_HANDLER = None
STREAM_HANDLER = None
STREAM_ERR_HANDLER = None
LOG_FILE_INIT = False

LOGGING_LEVELS = {
    # Critical: A serious error, indicating that the program itself may be unable to continue running.
    'CRITICAL': logging.CRITICAL,
    # Error: Due to a more serious problem, the software has not been able to perform some function.
    'ERROR'   : logging.ERROR,
    # Warning: An indication that something unexpected happened, or indicative of some problem in the near future (e.g.,
    #    `dis space low`). The software is still working as expected.
    'WARNING' : logging.WARNING,
    # Info: Confirmation that things are working as expected.
    'INFO'    : logging.INFO,
    # Debug: Detailed information, typically of interest only when diagnosing problems.
    'DEBUG'   : logging.DEBUG
    }

def get_header_text() -> str:
    # Build header text
    now = datetime.now()
    now_str = now.strftime('%x at %X')
    header = (
        f'----------------------------------------------------------------------------------',
        f'TidalPy - Tidal Heating Calculator and Orbital Evolver',
        f'Version: {TidalPy.__version__}',
        f'Primary Development by Joe Renaud, ca. 2016--2023',
        f'Found a bug or have a suggestion? Open a new issue at github.com/jrenaud90/TidalPy',
        f'----------------------------------------------------------------------------------',
        f'Run made on {now_str}.',
        f'Using Python {sys.version} on {sys.platform}.\n##\n'
        )
    header = '\n'.join(header)

    return header

class DeltaTimeFormatter(logging.Formatter):
    def format(self, record):
        duration = datetime.utcfromtimestamp(record.relativeCreated / 1000)
        record.delta = duration.strftime("%H:%M:%S::%f")
        return super().format(record)
FORMATTER = DeltaTimeFormatter('%(asctime)s(+%(delta)s) - %(levelname)-9s: %(message)s', "%Y-%m-%d %H:%M:%S")

def get_console_handler(error_stream=False):
    if error_stream:
        console_handler = logging.StreamHandler(sys.stderr)
        console_handler.setLevel(LOGGING_LEVELS[TidalPy.config['logging']['console_error_level']])
    else:
        if (not TidalPy.config['logging']['print_log_notebook']) and TidalPy._in_jupyter:
            return None
        
        console_handler = logging.StreamHandler(sys.stdout)
        console_handler.setLevel(LOGGING_LEVELS[TidalPy.config['logging']['console_level']])
    console_handler.setFormatter(FORMATTER)
    return console_handler

def get_file_handler() -> logging.FileHandler:
    """ Get file handler for TidalPy's logger. """
    assert TidalPy.config is not None

    if not TidalPy.config['logging']['write_log_to_disk']:
        # User does not want log written to disk.
        return None
    if (not TidalPy.config['logging']['write_log_notebook']) and TidalPy._in_jupyter:
        # User does not want log written while using Jupyter notebook; which we are in.
        return None
    if TidalPy.test_mode:
        # TidalPy tests are being run, don't write to disk.
        return None

    if TidalPy.config['logging']['use_cwd']:
        log_dir = os.path.join(TidalPy._output_dir, 'Logs')
    else:
        log_dir = get_log_dir()
    # Ensure directory exists
    Path(log_dir).mkdir(parents=True, exist_ok=True)

    # Find log filepath
    log_name = timestamped_str('TidalPy', date=True, time=True, second=True, millisecond=False, preappend=False)
    log_name += '.log'
    log_path = os.path.join(log_dir, log_name)

    # Create handler
    file_handler = logging.FileHandler(log_path)
    file_handler.setFormatter(FORMATTER)
    file_handler.setLevel(LOGGING_LEVELS[TidalPy.config['logging']['file_level']])
    return file_handler

# Initialize root logger. Its handlers will be used by other modules logger. 
_root_logger = logging.getLogger('TidalPy')

# Clear any handlers that might be present
_root_logger.handlers = list()

# Set base logging level to the lowest one (it will be overridden by the tidalpy config via handlers)
_root_logger.setLevel(1)

# Initialize handlers
# Log file handler
if FILE_HANDLER is None:
    FILE_HANDLER = get_file_handler()

if FILE_HANDLER is not None:
    _root_logger.addHandler(FILE_HANDLER)
    # Check if log file has been initialized
    if not LOG_FILE_INIT:
        # Add header text to log file
        with open(FILE_HANDLER.baseFilename, 'w') as log_file:
            log_file.write(get_header_text())
        LOG_FILE_INIT = True

# Console handler
if STREAM_HANDLER is None:
    STREAM_HANDLER = get_console_handler(error_stream=False)

if STREAM_HANDLER is not None:
    _root_logger.addHandler(STREAM_HANDLER)

# Console Error handler
if STREAM_ERR_HANDLER is None:
    STREAM_ERR_HANDLER = get_console_handler(error_stream=True)

if STREAM_ERR_HANDLER is not None:
    _root_logger.addHandler(STREAM_ERR_HANDLER)

def get_logger(logger_name: str) -> logging.Logger:
    # Get logger class
    logger = logging.getLogger(logger_name)

    # Perform any adjustments to the logger
    # None are currently required

    return logger
